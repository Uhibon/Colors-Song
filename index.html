<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Colors Video — Voice Boost + Fun FX (No Muting)</title>
<style>
  :root { --card-max-w: 92vw; --card-max-h: 92svh; }
  body {
    margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    background: #e6f2ff; min-height: 100svh; display: grid; place-items: center;
    overflow: hidden; padding-bottom: env(safe-area-inset-bottom);
  }
  .wrap {
    width: min(1000px, var(--card-max-w)); max-height: var(--card-max-h);
    background: rgba(255,255,255,.95); border-radius: 16px; box-shadow: 0 6px 24px rgba(0,0,0,.15);
    padding: 12px 14px 16px; box-sizing: border-box; display: grid; gap: 12px;
    grid-template-rows: auto 1fr auto auto; /* status, video, controls, fx */
  }
  .row { display: flex; gap: 8px; align-items: center; justify-content: center; flex-wrap: wrap; }
  .btn {
    appearance: none; border: 0; padding: 10px 12px; border-radius: 12px;
    background: #edf3ff; color: #0b61ff; font-weight: 700; cursor: pointer;
    box-shadow: 0 2px 8px rgba(0,0,0,.15);
  }
  .btn.primary { background: #0b61ff; color: #fff; }
  .btn.pink { background: #ff6ec7; color: #fff; }
  .btn:active { transform: translateY(1px); }
  .btn.choice.active { background:#0b61ff; color:#fff; }
  video {
    width: 100%; border-radius: 12px; background: #000;
    box-shadow: inset 0 0 0 2px rgba(0,0,0,.06);
  }
  .alert {
    display:none; background:#ffe8ea; color:#92001c; border:1px solid #ffb7c1;
    padding:8px 12px; border-radius:10px; font-weight:700; text-align:center;
  }
</style>
</head>
<body>
  <div class="wrap">
    <!-- Status (shows if Colors.mp4 is missing or fails to load) -->
    <div class="row"><div id="status" class="alert"></div></div>

    <!-- Native controls for sanity checks -->
    <video id="vid" src="Colors.mp4" controls playsinline></video>

    <!-- Transport + simple speed + volume -->
    <div class="row">
      <button id="back5" class="btn primary" title="Back 5s">⟵ 5s</button>
      <button id="play"  class="btn primary" title="Play/Pause (Space)">▶ Play</button>
      <button id="pause" class="btn primary" title="Pause">⏸ Pause</button>
      <button id="fwd5"  class="btn primary" title="Forward 5s">5s ⟶</button>

      <span style="margin-left:12px"></span>
      <button id="slowBtn" class="btn choice"  title="0.85×">Slow</button>
      <button id="normBtn" class="btn choice active" title="1.00×">Off</button>
      <button id="fastBtn" class="btn choice"  title="1.25×">Fast</button>

      <span style="margin-left:12px"></span>
      <input id="volume" type="range" min="0" max="1" step="0.01" value="1" title="Volume"/>
    </div>

    <!-- Fun FX + FX On/Off (no muting; FX layers on top of original) -->
    <div class="row">
      <button id="fxToggle" class="btn primary" title="Toggle effects">FX: Off</button>
      <button data-fx="none"      class="btn">None</button>
      <button data-fx="chipmunk"  class="btn">Chipmunk</button>
      <button data-fx="deep"      class="btn">Deep</button>
      <button data-fx="robot"     class="btn">Robot</button>
      <button data-fx="telephone" class="btn">Telephone</button>
      <button data-fx="echo"      class="btn">Echo</button>
      <button data-fx="cave"      class="btn">Cave</button>
      <button data-fx="alien"     class="btn">Alien</button>
    </div>
  </div>

<script>
(async function(){
  const DEFAULT_SRC = 'Colors.mp4'; // exact case for GitHub Pages
  const vid = document.getElementById('vid');
  const statusEl = document.getElementById('status');

  // --- Status helper ---
  function showStatus(msg){ statusEl.innerHTML = msg; statusEl.style.display = 'block'; }
  function hideStatus(){ statusEl.style.display = 'none'; }
  vid.addEventListener('error', () => {
    showStatus(`Couldn’t load <b>${DEFAULT_SRC}</b>.<br>
      Make sure it’s in the same folder and the name matches <b>exactly</b> (case-sensitive).`);
  });

  // --- Transport & simple speed ---
  const playBtn  = document.getElementById('play');
  const pauseBtn = document.getElementById('pause');
  const back5    = document.getElementById('back5');
  const fwd5     = document.getElementById('fwd5');
  const slowBtn  = document.getElementById('slowBtn');
  const normBtn  = document.getElementById('normBtn');
  const fastBtn  = document.getElementById('fastBtn');
  const volume   = document.getElementById('volume');

  function setSpeed(v){
    const rate = Math.max(0.25, Math.min(2.0, v));
    vid.playbackRate = rate;
    [slowBtn, normBtn, fastBtn].forEach(b => b.classList.remove('active'));
    if (rate < 1.0) slowBtn.classList.add('active');
    else if (rate > 1.0) fastBtn.classList.add('active');
    else normBtn.classList.add('active');
  }
  playBtn.addEventListener('click', async () => { hideStatus(); try{ await vid.play(); }catch{} });
  pauseBtn.addEventListener('click', () => vid.pause());
  back5.addEventListener('click', () => { vid.currentTime = Math.max(0, vid.currentTime - 5); });
  fwd5.addEventListener('click',  () => { vid.currentTime = Math.min((vid.duration||1e9)-0.001, vid.currentTime + 5); });
  slowBtn.addEventListener('click', () => setSpeed(0.85));
  normBtn.addEventListener('click', () => setSpeed(1.00));
  fastBtn.addEventListener('click', () => setSpeed(1.25));
  setSpeed(1.00);

  window.addEventListener('keydown', (e) => {
    if (e.code === 'Space'){ e.preventDefault(); if (vid.paused) playBtn.click(); else pauseBtn.click(); }
    if (e.key === 'ArrowLeft')  back5.click();
    if (e.key === 'ArrowRight') fwd5.click();
  });

  // Volume controls BOTH the video element and the FX bus (to keep levels matched)
  let master = null;
  function setVolume(v){
    const vv = Math.max(0, Math.min(1, v));
    vid.volume = vv;
    if (master) master.gain.value = vv;
  }
  volume.addEventListener('input', (e)=> setVolume(parseFloat(e.target.value)));

  // --- WebAudio: Voice Boost (mid/side + speech EQ/comp) + FX (layered) ---
  const fxToggle   = document.getElementById('fxToggle');
  const fxButtons  = document.querySelectorAll('[data-fx]');
  const AudioCtx   = window.AudioContext || window.webkitAudioContext;

  let ctx, srcNode, splitter, merger, directWet, echoMix, reverbMix, hp, bp, lp, shaper, delay, fb, convolver, trem, lfo, lfoGain;
  let midLMix, midRMix, sideLMix, sideRMix;
  let midBus, sideBus, midHP, midPresence, midDeess, midComp, sideHP, sideAtten;
  let fxEnabled = false; // FX OFF initially (and never mutes)

  function makeDistortion(amount=0){
    const k = amount, n = 44100, curve = new Float32Array(n), deg = Math.PI/180;
    for (let i=0;i<n;i++){ const x = i*2/n - 1; curve[i]=(3+k)*x*20*deg/(Math.PI + k*Math.abs(x)); }
    return curve;
  }

  async function ensureAudioGraph(){
    if (ctx) return;
    ctx = new AudioCtx();
    await ctx.resume().catch(()=>{});

    // Source -> split L/R
    srcNode  = ctx.createMediaElementSource(vid);
    splitter = ctx.createChannelSplitter(2);
    merger   = ctx.createChannelMerger(2);
    srcNode.connect(splitter);

    // Mid = (L+R)/2 (emphasize center/voice)
    const gLM = ctx.createGain(); gLM.gain.value = 0.5;
    const gRM = ctx.createGain(); gRM.gain.value = 0.5;
    splitter.connect(gLM, 0); splitter.connect(gRM, 1);
    midBus = ctx.createGain();
    gLM.connect(midBus); gRM.connect(midBus);

    // Speech chain on Mid
    midHP = ctx.createBiquadFilter(); midHP.type = 'highpass'; midHP.frequency.value = 150; midHP.Q.value = 0.7;
    midPresence = ctx.createBiquadFilter(); midPresence.type='peaking'; midPresence.frequency.value=3000; midPresence.Q.value=1.2; midPresence.gain.value=4;
    midDeess = ctx.createBiquadFilter(); midDeess.type='peaking'; midDeess.frequency.value=7500; midDeess.Q.value=3.0; midDeess.gain.value=-3;
    midComp = ctx.createDynamicsCompressor(); midComp.threshold.value=-18; midComp.knee.value=2; midComp.ratio.value=3; midComp.attack.value=0.008; midComp.release.value=0.12;
    midBus.connect(midHP).connect(midPresence).connect(midDeess).connect(midComp);

    // Side = (L-R)/2 (reduce sides ~40%)
    const gLS = ctx.createGain(); gLS.gain.value = 0.5;
    const gRS = ctx.createGain(); gRS.gain.value = -0.5;
    splitter.connect(gLS, 0); splitter.connect(gRS, 1);
    sideBus = ctx.createGain();
    sideHP  = ctx.createBiquadFilter(); sideHP.type='highpass'; sideHP.frequency.value=100; sideHP.Q.value=0.7;
    sideAtten = ctx.createGain(); sideAtten.gain.value = 0.6;
    gLS.connect(sideBus); gRS.connect(sideBus);
    sideBus.connect(sideHP).connect(sideAtten);

    // Reconstruct stereo (for the processed layer)
    midLMix  = ctx.createGain(); midLMix.gain.value = 1.0;
    midRMix  = ctx.createGain(); midRMix.gain.value = 1.0;
    sideLMix = ctx.createGain(); sideLMix.gain.value = 1.0;
    sideRMix = ctx.createGain(); sideRMix.gain.value = -1.0;
    midComp.connect(midLMix);  midComp.connect(midRMix);
    sideAtten.connect(sideLMix); sideAtten.connect(sideRMix);

    midLMix.connect(merger, 0, 0);  sideLMix.connect(merger, 0, 0);
    midRMix.connect(merger, 0, 1);  sideRMix.connect(merger, 0, 1);

    // FX chain on top of voice-boosted stereo
    const preFX = ctx.createGain();
    merger.connect(preFX);

    // Processed buses (no dry duplication — original video provides dry)
    directWet = ctx.createGain();  directWet.gain.value = 0.0;
    echoMix   = ctx.createGain();  echoMix.gain.value   = 0.0;
    reverbMix = ctx.createGain();  reverbMix.gain.value = 0.0;

    // Tremolo (Alien)
    trem = ctx.createGain(); trem.gain.value = 1.0;
    lfo  = ctx.createOscillator(); lfo.type='sine'; lfo.frequency.value = 0;
    lfoGain = ctx.createGain(); lfoGain.gain.value = 0;
    lfo.connect(lfoGain).connect(trem.gain); lfo.start();

    // Filters
    hp = ctx.createBiquadFilter(); hp.type='highpass'; hp.frequency.value=20; hp.Q.value=0.7;
    bp = ctx.createBiquadFilter(); bp.type='bandpass'; bp.frequency.value=1000; bp.Q.value=0.1;
    lp = ctx.createBiquadFilter(); lp.type='lowpass';  lp.frequency.value=20000; lp.Q.value=0.7;

    // Distortion
    shaper = ctx.createWaveShaper(); shaper.curve = makeDistortion(0); shaper.oversample='4x';

    // Echo & Reverb
    delay = ctx.createDelay(2.0); delay.delayTime.value=0.22;
    fb    = ctx.createGain();     fb.gain.value=0.32;
    delay.connect(fb).connect(delay);

    convolver = ctx.createConvolver();
    (function makeImpulse(seconds=2.0, decay=2.2){
      const rate=ctx.sampleRate,len=rate*seconds,ir=ctx.createBuffer(2,len,rate);
      for(let c=0;c<2;c++){ const ch=ir.getChannelData(c);
        for(let i=0;i<len;i++){ ch[i]=(Math.random()*2-1)*Math.pow(1-i/len,decay); } }
      convolver.buffer = ir;
    })();

    // Wire processed chain
    preFX.connect(trem).connect(hp).connect(bp).connect(lp).connect(shaper);
    shaper.connect(directWet);
    shaper.connect(delay).connect(echoMix);
    shaper.connect(convolver).connect(reverbMix);

    // Master out for processed path (adds on top)
    master = ctx.createGain(); master.gain.value = parseFloat(volume.value);
    directWet.connect(master);
    echoMix.connect(master);
    reverbMix.connect(master);
    master.connect(ctx.destination);
  }

  function resetFX(){
    if (!ctx) return;
    hp.frequency.value=20; hp.Q.value=0.7;
    bp.frequency.value=1000; bp.Q.value=0.1;
    lp.frequency.value=20000; lp.Q.value=0.7;
    shaper.curve = makeDistortion(0);
    directWet.gain.value = 0.0;
    echoMix.gain.value   = 0.0;
    reverbMix.gain.value = 0.0;
    lfo.frequency.value = 0;
    lfoGain.gain.value  = 0;
    trem.gain.value     = 1.0;
  }

  function setFX(name){
    if (!ctx) return;
    resetFX();

    // With no muting, we only ADD the processed sound on top of the original
    switch(name){
      case 'none':
        // leave all wet gains at 0 (pure original audio)
        break;

      case 'telephone':
        directWet.gain.value = 0.9;
        hp.frequency.value = 350; lp.frequency.value = 3300; bp.frequency.value = 1200; bp.Q.value = 0.8;
        break;

      case 'robot':
        directWet.gain.value = 0.9;
        hp.frequency.value = 180; lp.frequency.value = 3800; bp.frequency.value = 1200; bp.Q.value = 1.2;
        shaper.curve = makeDistortion(75);
        echoMix.gain.value = 0.08;
        break;

      case 'cave':
        directWet.gain.value = 0.2;
        reverbMix.gain.value = 0.45;
        echoMix.gain.value   = 0.10;
        delay.delayTime.value= 0.12;
        break;

      case 'echo':
        directWet.gain.value = 0.2;
        echoMix.gain.value   = 0.30;
        delay.delayTime.value= 0.22; fb.gain.value=0.32;
        break;

      case 'alien':
        directWet.gain.value = 0.9;
        bp.frequency.value = 900; bp.Q.value = 0.9;
        lfo.frequency.value = 35; lfoGain.gain.value = 0.5;
        break;

      case 'chipmunk': // playful: speed up (pitch up)
        directWet.gain.value = 0.9;
        hp.frequency.value = 120; lp.frequency.value = 18000;
        setSpeed(1.25);
        break;

      case 'deep': // playful: slow (pitch down)
        directWet.gain.value = 0.9;
        lp.frequency.value = 4800;
        setSpeed(0.85);
        break;
    }

    // Button styles
    fxButtons.forEach(b => b.classList.remove('primary'));
    const active = Array.from(fxButtons).find(b => b.dataset.fx === name);
    if (active) active.classList.add('primary');
  }

  function updateFxToggleButton(){
    fxToggle.textContent = fxEnabled ? 'FX: On' : 'FX: Off';
    fxToggle.classList.toggle('pink', fxEnabled);
    fxToggle.classList.toggle('primary', !fxEnabled);
  }

  // Toggle FX = just enable/disable the processed path (never touches video audio)
  fxToggle.addEventListener('click', async () => {
    await ensureAudioGraph();
    fxEnabled = !fxEnabled;
    updateFxToggleButton();
    if (!fxEnabled) {
      resetFX(); // silence the processed layer, original audio continues
    } else {
      const active = document.querySelector('[data-fx].primary')?.dataset.fx || 'none';
      setFX(active);
    }
  });
  updateFxToggleButton();

  // Preset buttons
  fxButtons.forEach(b => b.addEventListener('click', async (ev) => {
    await ensureAudioGraph();
    fxEnabled = true;
    updateFxToggleButton();
    setFX(ev.currentTarget.dataset.fx);
  }));

  // Build audio graph on first play or FX use
  playBtn.addEventListener('click', ensureAudioGraph, { once:true });
  fxButtons.forEach(b => b.addEventListener('click', ensureAudioGraph, { once:true }));

  // Volume init
  setVolume(parseFloat(volume.value));
})();
</script>
</body>
</html>
